// Each #kernel tells which function to compile; you can have many kernels
#define METHOD  1

#pragma kernel CalcMaxDelta
#pragma kernel CalcActivation
#pragma kernel ApplyColors



#include "ColorHelpers.hlsl"

struct Vertex
{
    unorm float4 color;
    float2 uv;
};

struct Triangle
{
    unorm float4 color;
    float2 uv;
    float size;
};

struct ShapeConfig
{
    int index;
    int channel;
};

Vertex LoadVertexFromBuffer(RWByteAddressBuffer buffer, int index)
{
    uint3 raw = buffer.Load3((index * 3) << 2);
    Vertex vert;
    vert.color = UnpackColor(raw.x);

    vert.uv = asfloat(raw.yz);
    return vert;
}

float AreaOfTriangle(float2 pointA, float2 pointB, float2 pointC)
{
    float a = length(pointA - pointB);
    float b = length(pointB - pointC);
    float c = length(pointC - pointA);
    float2 center = (pointA + pointB + pointC) / 3.;
    a = length(center - pointA);
    b = length(center - pointB);
    c = length(center - pointC);
    return (a + b + c) / 3.;

    //return (a + b + c) / 4.;
    float s = (a + b + c) / 2.;
    float area = sqrt(s * (s - a) * (s - b) * (s - c));
    return sqrt(area / 3.1415);
}

min16uint4 Load4Index(ByteAddressBuffer indexBuffer, int index)
{
    uint2 uInt2 = indexBuffer.Load2(index << 2);
    return UInt2ToUShort4(uInt2);
}

Triangle MakeTriangle(Vertex vA, Vertex vB, Vertex vC)
{
    Triangle o;
    o.color = (vA.color + vB.color + vC.color) / 3.;
    o.uv = (vA.uv + vB.uv + vC.uv) / 3.;
    if (length(o.color) > 0.)
        o.size = AreaOfTriangle(vA.uv, vB.uv, vC.uv);
    else
        o.size = 0;
    return o;
}

Triangle LoadTriangle(RWByteAddressBuffer colorBuffer, ByteAddressBuffer indexBuffer, int index)
{
    min16uint4 indices = Load4Index(indexBuffer, index);
    Vertex vA = LoadVertexFromBuffer(colorBuffer, indices.x);
    Vertex vB = LoadVertexFromBuffer(colorBuffer, indices.y);
    Vertex vC = LoadVertexFromBuffer(colorBuffer, indices.z);
    return MakeTriangle(vA, vB, vC);
}


min16uint4 LoadFromUShortBABuffer(ByteAddressBuffer buffer, int index)
{
    uint2 uInt2 = buffer.Load2(index << 2);
    min16uint2 xy = UIntToUShort2(uInt2.x);
    min16uint2 zw = UIntToUShort2(uInt2.y);
    return min16uint4(xy, zw);
}

float4 GetColorFromShapeConfig(ShapeConfig config)
{
    if (config.channel == 4)
        return float4(0, 0, 0, 1.);
    if (config.channel == 3)
        return float4(0, 0, 1., 0);
    if (config.channel == 2)
        return float4(0, 1., 0, 0);
    if (config.channel == 1)
        return float4(1, 0, 0, 0);
    return float4(0, 0, 0, 0);
}


RWTexture2D<float4> _HeatMapBuffer;
RWStructuredBuffer<float3> _VertexMaxBuffer;
StructuredBuffer<float3> _BlendShapeBuffer;
ByteAddressBuffer _IndexBuffer;
RWStructuredBuffer<float> _VertexActivationBuffer;
RWStructuredBuffer<float> _BlendShapeWeightBuffer;
RWByteAddressBuffer _ColorBuffer;
AppendStructuredBuffer<Triangle> _TriangleActivationBuffer;
StructuredBuffer<Triangle> _TriangleActivationStructuredBuffer;
RWStructuredBuffer<int> _ActivatedTriangleCountBuffer;
StructuredBuffer<ShapeConfig> _BlendShapeConfigBuffer;
int _VertexCount;
int _BlendShapeCount;
int _TriangleCount;
int2 _TextureDimensions;
float _Blend;
float4 _Color0;
float4 _Color1;
float4 _Color2;
float4 _Color3;

[numthreads(128, 1, 1)]
void CalcMaxDelta(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x >= _BlendShapeCount)
        return;

    int sidx = id.x * _VertexCount;
    float3 max = float3(0, 0, 0);
    float maxLength = 0;
    for (int i = 0; i < _VertexCount; i++)
    {
        float3 vert = _BlendShapeBuffer[i + sidx];
        float _length = length(vert);
        if (maxLength < _length)
        {
            maxLength = _length;
            max = vert;
        }
    }
    _VertexMaxBuffer[id.x] = max;
}

[numthreads(128, 1, 1)]
void CalcActivation(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x >= _BlendShapeCount * _VertexCount)
        return;
    int sidx = id.x / _VertexCount;
    int vidx = id.x % _BlendShapeCount;
    float3 vert = _BlendShapeBuffer[id.x];
    float l = length(vert);
    float3 max = _VertexMaxBuffer[sidx];
    float maxLength = length(max);
    float weight = _BlendShapeWeightBuffer[sidx];
    if (maxLength == 0 || l == 0)
        _VertexActivationBuffer[id.x] = 0;
    else
    {
        _VertexActivationBuffer[id.x] = (weight * l) / maxLength;
    }
    //if (maxLength == 0)
        //_VertexActivationBuffer[id.x] = 0;
        //_VertexActivationBuffer[id.x] = (weight);        
    //else
        //_VertexActivationBuffer[id.x] = (weight);  
        //_VertexActivationBuffer[id.x] = (weight * l) / maxLength;
}

[numthreads(256, 1, 1)]
void ApplyColors(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VertexCount)
        return;

    int cidx = id.x * 3;
    float4 activation = float4(0, 0, 0, 0);
    for (int i = 0; i < _BlendShapeCount; i++)
    {
        activation = saturate(activation + _VertexActivationBuffer[id.x + _VertexCount * i] * GetColorFromShapeConfig(_BlendShapeConfigBuffer[i]));

    }
    _ColorBuffer.Store((cidx << 2), PackColor(activation));
}
